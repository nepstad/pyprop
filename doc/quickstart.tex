\chapter{Quickstart}
The main idea behind pyprop is to try to extract some common features from every propagation problem and 
separate those from the project files into a general framework. 
That way one can easily let somebody else maintain the general framework, while keeping it easy to
integrate new features in the individual projects. Normal users should therefore try to avoid
modifying the files in the pyprop folder, and instead keep their own projects in a separate folder. 

During the course of this chapter, I will try to warn about some common pitfalls one might fall into
when migrating from a MATLAB environment, as well as explain some basic python commands. This is, however, 
not by any standards a python tutorial, and I refer to the official python tutorial \ref{pythonTut},
as well as the book by H.P. Langtangen \ref{langtangen} for a more thourough introduction to python, and
its applications to scientific computing.

\section{A simple example in great detail}
\subsection{The problem}
In this example, we will try to find the ground state energy of a 2D harmonic oscillator.
We will perform all our calculations in cartesian coordinates.

\subsection{Preparations}
Create a new folder outside the pyprop folder, and copy the contents of \inlinebash{examples/cartesian/groundstate/*} to
the new folder. This keeps the pyprop source tree clutter free, and makes it easier to integrate upgrades to pyprop.
\begin{bash}
	cd ..
	mkdir example1
	cd example1
	cp ../pyprop/examples/cartesian/groundstate/* .
\end{bash}
Open the file example.py in your favourite editor, and on line 22, change pyprop\_path to point to your pyprop folder.
If you followed the instructions above, the line should read
\begin{bash}
	pyprop_path = "../pyprop/"
\end{bash}

\subsection{A very short introduction to Python}
Start the python interpreter by executing \inlinebash{ipython} on the command line.. If you do not have ipython installed, 
you can start the standard python interpreter by calling \inlinebash{python}. The standard python 
interpreter is rather lacking when it comes to advanced interactive features, like command completion, command history and more. When python has started, you can execute the contents of example.py with the execfile() function. When you are done, 
and whish to exit python, press $<$CTRL$>$+D to mark EOF which causes the interpreter to terminate.
\begin{bash}
	ipython
	execfile("example.py")
\end{bash}

\subsubsection*{Execfile}
The execfile() function has the same effect as typing every line in the file into the editor manually. I.e. much the 
same effect as executing a .m file in MATLAB. This notes some important differences between function handling in 
Python and MATLAB:
\begin{itemize}
\item In MATLAB there is a distinction between function-files and command-files. There is no such distinction in Python
\item In MATLAB there can only be defined one function per file. In Python there are no such restrictions.
\item In MATLAB a function file is automatically reloaded every time a function is called. In Python a function has to
be redecleared in order to be changed. 
\end{itemize}
The last item means that whenever you make a change to a function in a file, this file must be execfile()'ed again for the
changes to be reflected in the Python environment.

\subsubsection*{Docstrings and comments}
Looking at example.py, the first ting you will see is the rather strange comment encapsulated in triple quotes ("""). This
is called docstrings, and is the normal way of documenting python modules. Text you write in triple quotes at the beginning 
of files, and functions, will be readily available in the interpreter. In the python interpreter, type
\begin{python}
	help FindGroundstate
\end{python}
Docstrings written anywhere else in the file will be treated more or less as multi-line comments. 

\subsubsection*{Importing modules}
Looking further down in example.py (lines 13-25) you will see various import statements. There are
\begin{python}
	import sys
	import os
\end{python}
Which imports the modules \inlinepy{sys} and \inlinepy{os}. These are standard modules in python, and after importing them this
way, their contents can be access with the prefiex \inlinepy{sys.} and \inlinepy{os.} respectively. I.e. you can get the version
of the currently running python interpreter by typing \inlinepy{sys.version}.

Next, you will see some alternative import statements
\begin{python}
	from pylab import *
	from numpy import *
\end{python}
These statements import everything from the pylab (MATLAB-like plotting module) and numpy (numerical arrays in python)
modules into the current namespace. To test numpy and pylab, type the following into the interpreter:
\begin{python}
	x = r_[-10:10:0.1]
	y = sin(x) * x**2
	plot(x, y)
\end{python}
If everything goes according to plan, you should now look at a plot of $x^2 \sin x $ for $-10 < x < 10$.

The last import statement imports the pyprop library from a specified folder into the pyprop namespace, and makes sure 
it is reloaded every time this file is executed.

\subsubsection*{Functions}
The rest of example.py is the definition of two functions, \inlinepy{FindGroundstate} and \inlinepy{Propagate}. 
Note how code blocks are defined by indentation, and not with "end"-statements, as in MATLAB. 
Python functions can take zero or more objects
as input, and return zero or more objects as output. In contrast to MATLAB, the return variables are not defined in the
method declaration header, but rather with a "return"-statement whenever the method should be terminated, and flow returned
to the caller. 

The function \inlinepy{FindGroundstate} has no input parameters, but returns two objects, the propagation object, and the 
ground state energy. Find the ground state energy of 2D hydrogen by typing
\begin{python}
	prop, energy = FindGroundstate()
\end{python}
After some time. Control should be returned to the interpreter, and you can inspect the energy by typing \inlinepy{energy} in
the interpreter. The variable prop is now an instance of the class pyprop.Problem, which is the central class in the
pyprop library. By typing \inlinepy{pyprop.} and pressing $<$TAB$>$, the ipython autocomplete function will list the members of
the prop object. Type \inlinepy{pyprop.psi.GetNorm()} to get the square of the weighted 2-norm of the wavefunction (in other 
words: the inner product of the wavefunction with itself).

\subsection{The details of pypropagation}
We shall now consider the method \inlinepy{FindGroundstate} in more detail, in order to understand what is required for 
propagation with pyprop.
\begin{python}
	conf = pyprop.Load("find_groundstate.ini")
\end{python}
Loads the configuration file "find\_groundstate.ini" into a configuration object. 
\begin{python}
	prop = pyprop.Problem(conf)
\end{python}
Creates a propagation object (of class pyprop.Problem). This is the main object of propagation, and has knowledge of 
the wavefunction, the potentials, and the transformations needed to propagate the wavefunction. 
\begin{python}
	prop.SetupStep()
\end{python}
Sets up the propagation object to its initial state. This includes allocating data for the wavefunction and transformations,
creating the static potential arrays, Running every transformation once, in order to ensure that they're initialized properly
\footnote{The fourier transformations used (FFTW with FFTW\_MEASURE) produces garbage the first time they are called. Calling
them once in the SetupStep avoids all such problems}. This method can be called later, if one wants to reset the propagation
object to its initial state.
\begin{python}
	for t in prop.Advance(10):
	    print "t =", t, "E =", prop.GetEnergy()
\end{python}
Iterates over all timesteps for $0 \ge t \ge T_{max}$, where $T_{max}$ is given by the duration specified in the 
configuration file. While propagating timesteps, the propgagation routine will break 10 evenly spaced times to print
out a line containing the current propagated time, and the approximated ground state energy at this timestep (Note 
that the GetEnergy() method actually propagates the wavefunction another timestep).

Technically, prop.Advance() returns a generator object, which propagates the problem to its end, yielding at a number of 
timesteps see the Python tutorial \cite{pythonTut} for more information about generators.

When the for loop exits, the wavefunction is assumed to be fully converged to the ground state (Looking at the output
from the propagation, we clearly see that this is the case). 
\begin{python}	
	prop.SaveWavefunction("groundstate.dat")
\end{python}
Saves the current wavefunction to the file "groundstate.dat". The file format used is the binary format used
by the cPickle module, and it can be loaded with a call to \inlinepy{prop.LoadWavefunction()}. The format is, however, not 
easily interpreted in any other language but python. As long as python is the only language used for manipulating the 
wavefunction, this is not a problem. However, sometimes it is favorable to be able to load the wavefunction in some
other language (i.e. MATLAB or Fortran90). For such situations \inlinepy{prop.SaveWavefunctionAscii()} and
\inlinepy{prop.LoadWavefunctionAscii()}
can be used. It is much slower than pickle, produces much larger files, and can only write 1D or 2D arrays, but the files
produced are easily readable in MATLAB (by the \inlinepy{load} function)

\subsection{The configuration file}
The code in the above section is fairly standard. It will be common for most pyprop based projects. The main difference
will usually be what done with the system in each print step, and which configuration file is loaded. In this section we 
will look at configuration file format, and try to see what the different sections mean, and how they interact.

\subsubsection*{Configuration basics}
The configuration file format used, is one based on the common .ini file format. The file is divided into different
sections, each labeled with a name enclosed in square brackets(i.e. [Representation]). All lines following the section
label until the next section label or EOF are said to belonging to that section. Every line belonging to a section is
empty, or on the format 
\begin{verbatim}
	<name> = <value>
\end{verbatim}
Where $<$name$>$ can be any valid python variable name in lower case (Upper case letters will be converted to lower case during
parsing). Basically, this means that it must start with a letter, and can not contain any spaces or operators. 
$<$value$>$ can be any valid python expression. During parsing, $<$value$>$ is evaluated as a python statement 
(with the \inlinepy{eval} function). Any characters following the comment character (\#) on a line, will be ignored.

\noindent This means that the following are valid variable declarations
\begin{python}
	my = 10               # An integer
	variable = 10.5       # A float
	is = [1, 2, 3, 4]     # A list
	the_best = "hello"    # A string
	angle = pi/2.         # an expression
	func = lambda x: x**2 # A lambda function
\end{python}
While the following are variable declarations are not
\begin{python}
	my variable = 10      # Names can not contain space
	my_string = hello     # Strings must be enclosed in ""
	10er = 10 * 0.5       # Variable names must start with a letter
	N = 100               # Case will be lost during parsing
\end{python}

\subsubsection*{Configuration sections}
There are several configuration sections with special meaning to pyprop. The ones that are most used are [Representation], 
[InitialCondition], [Propagation] and [Import]. In addition the configured propagator may require additional 
configuration sections to function properly.

\subsubsection*{[Representation]}
The representation section has information on which representation to choose for the initial wavefunction. Transformations
may change the current representation later, but this will be the basic representation of your problem. 
\begin{python}
	[Representation]
	type = core.CartesianRepresentation_2
	rank = 2
	rank0 = [-8, 8, 64]
	rank1 = [-8, 8, 64]
\end{python}
In our case, we are
using a two dimensional cartesian representation. The type of representation is given in the variable \inlinepy{type}, which
is a reference to a core class (and should therefore not be enclosed in quotes). Following the type is the \inlinepy{rank} 
of the problem. The rank is the same as the number of dimensions used for the wavefunction. 
This must match what the representation given in \inlinepy{type} expects.

For a cartesian representation we must also specify the dimensions for each rank. This is done on separate lines, 
starting on \inlinepy{rank0}. Each line should have the name \inlinepy{rank<rankindex>}, and a list as value. The list is
interpreted as \inlinepy{[min, max, count]}. This creates an equispaced grid starting on (and including) \inlinepy{min},
going to (but excluding) \inlinepy{max}, with \inlinepy{count} gridpoints.

For other representations the number of grid points will most likely not be specified in the same way.

\subsubsection*{[InitialCondition]}
The initial condition section specifies how the initial wavefunction should be initialized.
\begin{python}
	[InitialCondition]
	type = InitialConditionType.Function
	function = lambda conf, x: 1
\end{python}
Type specified by which method the initial function should be created. "InitialConditionType.Function" means that the
wavefunction should be created from an inline python function. The function variable declares the function which evaluates
the initial wavefunction at every grid point, and will most oftenly be an inline lambda expression. The function should take
two parameters, the first being the current config section, and the second beeing a list containing the grid points.

\subsubsection*{[Propagation]}
The propagation section specifies how the propagator should be created, and gives details on how we should
proceed from one timestep to another.
\begin{python}
	[Propagation]
	propagator = CartesianPropagator
	potential_evaluation = ["StaticPotential"]
	timestep = -0.01j
	duration = 10
	renormalization = True
\end{python}
The most important thing to note here, is the propagator variable, which specifies which propagator class to use
for propagating the wavefunction. This propagator must know how to handle the representation specified in the
representation section. Another important concept is potential evaluation. This variable gives a list of the
"normal" potentials used in this propagation. In this case it is only one potential, namely "StaticPotential". 
Pyprop looks for a configuration section with the same label as the name of the potential, and tries to create
a potential based on this. The propagators will then use these potentials in the propagation.

\subsubsection*{[StaticPotential]}
The potential section is special in that the label is insignificant, it must only match the name reffered to in
the propagation section. It's layout is very similar to the initial condition section.
\begin{python}
	[StaticPotential]
	type = PotentialType.Static
	function = lambda conf, x: 0.5 * conf.strength**2 * sum(asarray(x)**2) 
	strength = 1
\end{python}
The Static potential type means that this potential is evaluated once (in the setup step), and stored in an array.
In contrast, using the Dynamic potential type requires pyprop to evaluate the potential at every time step. 
Using a static potential is extremely much faster, but it requires a bit of memory (sizeof(complex) * \# gridpoints)
in order to store the potential.

The function is of the same type as the one used in the initial condition section: The first argument is the current
configuration section (used here to specify the harmonic frequency of the harmonic oscillator). The second argument is
a list of the current grid point coordinates $[x_0, x_1, ..., x_{rank}]$. 

The asarray function converts the list to a
numeric array, the squaring is element wise and the sum function takes the sum over every component in the numerical 
array.

\subsubsection*{[Distribution]}
\begin{python}
	[Distribution]
	model = "LargestStride"
	transpose_model = 2 #core.TransposeModel.TRANSPOSE_SEMI
\end{python}
Please ignore this section for now. It is related to parallelization, and it is not yet working
properly.

\subsubsection*{Try it out!}
\begin{enumerate}
\item Find the ground state energy of a 1D and 3D harmonic oscillator.

\item Find the ground state of the potential 
\begin{equation}
	V = x_0^2/3. + 2. x_1^2/3.
\end{equation}

\item Find the ground state energy of 2D hydrogen 
(use a softed potential in order to avoid the singularity at $x = y = 0$).
\end{enumerate}

%-------- 
\section{More advanced potentials}
In this section, we will modify the example from the previous section, to allow for more advanced 
potentials. In the previous example, the potential was specified by an inline lambda function. While
this is certainly convenient for simple potentials, it can be tedious to express a complex potential 
expression in one statement. 

\subsection{Python potentials}
It is,possible to define the potential as a stand alone function 
and only refer to its in the configuration file. First, add the following function to example.py.
\begin{python}
	def MyPotential(conf, x):
	    V1 = 0.5 * conf.omega1 * x[0]**2
	    V2 = 0.5 * conf.omega2 * x[1]**2
	    return V1 + V2
\end{python}
Save the file and run \inlinepy{execfile("example.py")} in the python interpreter in order to load the 
changes to example.py.

Next, we must refer to this potential function in the configuration file. We could, of course, 
simply change the existing StaticPotential section, but in order to make it easy to switch between
the potentials, we will add a new section to find\_groundstate.ini
\begin{python}
	[PythonPotential]
	type = PotentialType.Static
	function = MyPotential
	omega1 = 1.0
	omega2 = 0.5
\end{python}
Now, change the \inlinepy{potential\_evaluation} variable in the \inlinepy{Propagation} section to use PythonPotential.
\begin{python}
	potential_evaluation = ["PythonPotential"]
\end{python}

While the python potentials are easy to use and modify, there is no support for time dependent python potentials 
in pyprop. The reason for this is execution speed; Python potentials requires a call to a python function for every
grid point every time the potential is evaulated. The overhead of calling functions in python would completely ruin
every hope of any good performance. This overhead may also become an issue for very large time independent problems,
where the set up step takes an inproportionate amount of time, compared with the rest of the calculations.

\subsection{Compiled potentials}
An alternative to python potentials are the compiled potentials. Compiled potentials are, as the name suggest, written 
in C++ and compiled into a python module. The fact that it is compiled instead of interpreted, automatically makes it a
lot faster and furthermore, due to some C++ template tricks, no function calls are needed for every grid point. 

\subsubsection*{Getting the template}
In order to make compilation of potentials as easy as possible, a template is provided in the folder 
\inlinebash{pyprop/examples/template}. Copy this template to your project folder, and create a symlink
to pyprop in the current folder called pyprop
\begin{bash}
	cp ../pyprop/examples/template/* .
	ln -s ../pyprop pyprop
\end{bash}
This should give you three new files in the project folder: 
\begin{itemize}
	\item \inlinebash{potential.cpp}, the source file containing the potential.
	\item \inlinebash{wrapper.pyste}, describing the python wrapper in pyste format.
	\item \inlinebash{Makefile}, one makefile to rule it all.
\end{itemize}

\subsubsection*{potential.cpp}
Open potential.cpp in your favorite editor. In a real project, you would probably rename the PotentialTemplate
class to something more describing, however in this simple example that is not necessary. 
In the PotentialTemplate class, remove the line declaring the field \inlinec{param}, and replace it with.
\begin{c++}
	//potential parameters
	double omega1;
	double omega2; 
\end{c++}
In the method \inlinec{ApplyConfigSection}, replace the call to config.Get() by
\begin{c++}
	config.Get("omega1", omega1);
	config.Get("omega2", omega2);
\end{c++}
And finally, in the method \inlinec{GetPotentialValue}, add the following lines
\begin{c++}
	double V1 = 0.5 * omega1 * sqr(pos(0));
	double V2 = 0.5 * omega2 * sqr(pos(1));
	return V1 + V2;
\end{c++}
You should now have a fully working potential implementing a 2D Harmonic oscillator with different harmonic frequencies
in the $x_0$ and $x_1$ direction.

\subsubsection*{wrapper.pyste}
Wrapper.pyste is a file describing to pyste which parts from potential.cpp should be exposed to python. This file is very
simple, containing ony ~3 lines. One to declare the potential evaluator, and 2 to use it on the declared potential with
different ranks. It is necessary to use the potential for each rank you whish to use. 

\subsubsection*{Makefile}
The makefile is mostly set up correctly, you need only specify the path (may be a relative path) to where pyprop 
is installed (../pyprop), and a name for the extention module. Call it \inlinebash{libcpotential} or something else of your
choice, so that line 11 in Makefile reads
\begin{verbatim}
	MODULENAME   := libcpotential
\end{verbatim}

The python module should now compile without errors or warnings if you type \inlinebash{make} into the console.

\subsubsection*{Loading the Python module}
Add the following to the top of example.py:
\begin{python}
	from libcpotential import *
\end{python}
And re-execute the file to load the changes. 
This should load the recently compiled libcpotential module and import everything in it into the current namespace.
You can verify that you have two new python classes PotentialTemplate\_1 and PotentialTemplate\_2 in your namespace, which 
corresponds to the C++ PotentialTemplate template class for rank 1 and rank 2 problems correspondingly.

\subsubsection*{Using the compiled potential}
In find\_groundstate.ini, add the following section
\begin{python}
	[CompiledPotential]
	type = PotentialType.Static
	classname = "PotentialTemplate"
	omega1 = 1.0
	omega2 = 0.5
\end{python}
And change \inlinepy{potential\_evaluation} to 
\begin{python}
	potential_evaluation = ["CompiledPotential"]
\end{python}
Notice that compared with python potentials, compiled potentials are specified with a classname variable instead of function
variable. Also note that this is a string, and that the trailing "\_1" or "\_2" specifying rank is omitted. This is because
the pyprop automatically appends the correct postfix for rank specified in the representation section.

You can now test that your new compiled potential gives the same energy as the python potential by running
\inlinepy{FindGroundstate()} in the python interpreter. The performance impact of using dynamic instead of static potentials
can be demonstrated by timing the call to \inlinepy{FindGroundstate()}. If you have ipython, you can type
\begin{python}
	%prun FindGroundstate()
\end{python}
Which will give you the total time used, along with a corse profile of the run. On my laptop, this takes 3.9 seconds. 
Changing to dynamic potentials, by changing the type in CompiledPotential to
\begin{python}
	type = PotentialType.Dynamic
\end{python}
And timing \inlinepy{FindGroundstate()} again. On my laptop this takes 7.1 seconds, and now the potential evaulation is 
by far the 
task that consumes most time during propagation. This may be surprising as asymptotically the fourier transform should be more
expensive ($n \log n$ instead of $n$).


\section{A More Complicated Example}
\subsection{Problem}
In this section, we will try to find the ionization probability of hydrogen, when exposed to linear polarized light.
To do that, we will first calculate the ground state of hydrogen using imaginary time propagation, and then use
a dynamic potential to represent the laser, and an absorbing boundary to calculate the ionization probability.

We will use spherical coordinates for our calculations. When using light polarized in the $z$ direction there is a
$\phi$-symmetry in the system, and thus there is no need to actually include phi in the calculations. In pyprop this
is known as the \inlinepy{ReducedSphericalRepresentation}. We will be using a \inlinepy{CombinedRepresentation} to combine
the angular representation with a radial representation. This way it is possible to easily change the radial representation 
from an equidistant representation (known as a CartesianRepresentation in pyprop) to a representation based on transformed
grids or orthogonal polynomials.

If you have not done so already, please read the previous section first, as this example will not explain any python basics
and will not be as detailed in the description of configuration files and such. The entire example is also available in \inlinebash{pyprop/examples/combined/hydrogen_ionization}

\subsection{Perparations}
There are several steps that must be completed in order to calculate the ionization probability.
\begin{itemize}
 \item Set up a folder with a basic pyprop project
 \item Create a configuration file with the correct representation, propagator etc.
 \item Create a static potential for the Hydrogen problem
 \item Find and save the ground state of our static problem
 \item Create the dynamic laser potential
 \item Load the ground state, and propagate to find the ionization probability
 \item Repeat the previous step for different electric field strengths
\end{itemize}

\subsection{Create a basic pyprop project}
At a minimum, a pyprop project usually contains a Makefile, a c++ potential file, a python wrapper file, a configuration file, 
and a python file. Good templates for the Makefile, potential file and wrapper file can be found in \inlinebash{examples/template}.
Create a folder and copy these files to it (this assumes pyprop and the project folder will be sibling folders).
\begin{bash}
	mkdir hydrogen_ionization
	cd hydrogen_ionization
	cp ../pyprop/examples/template/* .
\end{bash}
In order for your project to know where to find pyprop, create a symbolic link to the pyprop folder in the project folder, and 
call it pyprop.
\begin{bash}
 	ln -s ../pyprop pyprop
\end{bash}
We will also need a python file to contain our helper functions. Create a file called \inlinebash{example.py} and open it in your 
favorite editor, and add the following lines (Please note that there should not be any whitespace to the left of the text).
\begin{python}
	#Import system modules
	import sys
	import os
	from pylab import *
	from numpy import *

	#Load pyprop
	sys.path.insert(1, os.path.abspath("./pyprop"))
	import pyprop
	pyprop = reload(pyprop)

	#Load the project module
	from libpotential import *
\end{python}
The first lines imports some common system modules, as well as pylab (plotting) and numpy (numeric arrays) which are nice to have. 
available. The second paragraph adds \inlinebash{./pyprop} to the search path when loading modules, and imports pyprop. The last paragraph
imports the module containing the potentials we will create for this project.

We now have a basic pyprop project. In order to test it, we must first make the potential-module
\begin{bash}
	make clean
	make
\end{bash}
To test that everything is working so far, start up python, and execute the example.py file
\begin{bash}
 	ipython
	execfile("example.py")
\end{bash}

\subsection{Create a configuration file}
In order to tell pyprop what kind of problem to solve, we will need a configuration file. As described in the previous example, a configuration file has several sections, each having different configuration variables. We will use a 2D \inlinepy{CombinedRepresentation} for this project. rank 0 will be the radial rank, while rank 1 will be the angular rank. Create a file called \inlinebash{config.ini}, and open it in your favourite text editor, and add the following lines
\begin{python}
[Representation]
rank = 2
type = core.CombinedRepresentation_2
representation0 = "RadialRepresentation"
representation1 = "AngularRepresentation"

[RadialRepresentation]
type = core.CartesianRepresentation_1
rank = 1
rank0 = [-10, 10, 256]

[AngularRepresentation]
type = core.ReducedSphericalHarmonicRepresentation
rank = 1
maxl = 16

[InitialCondition]
type = InitialConditionType.Function
function = lambda conf, x: x[0] * exp(- abs(x[0]))

[Potential]
type = PotentialType.Static
classname = "CoulombPotential"
charge = -1

[Propagation]
potential_evaluation = ["Potential"] 
propagator = CombinedPropagator
propagator0 = "RadialPropagator"
propagator1 = "AngularPropagator"
timestep = -0.01j
duration = 15
renormalization = True
silent = False

[RadialPropagator]
propagator = CartesianRadialPropagator
mass = 1.0

[AngularPropagator]
propagator = ReducedSphericalPropagator
mass = 1.0
radial_rank = 0
\end{python}
This will set up a representation with $L_{max} = 16$, and 256 radial grid points between $-10$ and $10$. The anti-symmetrization is due to the boundary conditions. The propagator is set up with effective mass = $1$, and to use imaginary time, and a potential called CoulombPotential which is expected to be found in the potential module of this project.

\subsection{Set Up the Static Potential}
We will use a static potential for the Coulomb potential, which will is expected to be found in the potential module. We must therefore set up this potential in \textit{potential.cpp}. Open up potential.cpp in your favourite editor, and make the following changes. 
\begin{itemize}
 \item On line 5, change the name of the class from \inlinec{PotentialTemplate} to \inlinec{CoulombPotential}
 \item On line 13, rename the \inlinec{param} variable to \inlinec{charge} (The line should now read \inlinec{double charge;})
 \item On line 22, change the line to read the config varable \textit{"charge"} into the C++ variable \textit{charge} (The line should now read \inlinec{config.Get("charge", charge);})
 \item Finally, change the body of the method \inlinec{GetPotentialValue} to implement the Coulomb potential with a cutoff.
\end{itemize}
\begin{c++}
inline double GetPotentialValue(const blitz::TinyVector<double, Rank> &pos)
{
	double r = std::abs(pos(0));
	if (r < 10e-5)
	{
		return 0;
	}
	double V = charge / r;
	return V;
}
\end{c++}

In order to make this potential available to python, we must create a wrapper for it. This is done in wrapper.pyste. If you open
wrapper.pyste in a text editor, there are two paragraphs. The first declares a potential evaluator, and the second uses that 
potential evaluator to wrap the potential \inlinec{PotentialTemplate} in both a $1D$ and a $2D$ variant. For our purposes, we only
need a $2D$ wrapper of \inlinec{CoulombPotential}. Replace the file to contain the following lines
\begin{python}
#declare potential evaluator for cartesian-like potentials
PotentialEvaluator = Template("DynamicPotentialEvaluator", "potential.cpp")

#Compile potential for 2D
PotentialEvaluator("CoulombPotential<2> 2","PotentialTemplate_2")
\end{python}
Now, in order to use this potential in python, you must recompile the potential module
\begin{bash}
	make clean
	make
\end{bash}
The make clean is necessary because we changed the wrapper file, otherwise, a simple \textit{make} would suffice.

\subsection{Find the Ground State}
We now have a configuration file and a potential, and need to tell pyprop to use these to calculate the groundstate. This will be done in steps
\begin{itemize}
 \item Load the configuration file 
 \item Create a pyprop Problem object based on the configuration
 \item Propagate
\end{itemize}

To load the configuration file, we use the command \inlinepy{pyprop.Load(filename)}, but because we want to extend this further later on, we will make a function that wraps this functionality. Add the following function to example.py
\begin{python}
def SetupConfig(**args):
	#Decide which config file to use
	configFile = "config.ini"
	if "config" in args:
		configFile = args["config"]

	#Load the config file
	conf = pyprop.Load(configFile)

	#Modify the config
	if "imtime" in args:
		imtime = args["imtime"]
		propSection = conf.Propagation
		dt = abs(propSection.timestep)
		renormalize = False
		if imtime:
			dt = -1.0j * dt
			renormalize = True

		propSection.timestep = dt
		propSection.renormalization = renormalize
	
	return conf
\end{python}
The "Modify the config" part is not strictly necessary, but serves as an example of how the config can be modified after it has been loaded from file. If imtime is passed as a parameter to \inlinepy{SetupConfig}, it will override the timeste and renormalization values specified in the config file.

Next, we will use the config object to create a pyprop Problem object, and set that up to be ready for propagation. Add the following function to your example.py
\begin{python}
def SetupProblem(**args):
	conf = SetupConfig(**args)
	prop = pyprop.Problem(conf)
	prop.SetupStep()
	return prop
\end{python}

Finally, we will add a small function to propagate the solution for the duration specified in the configuration file, and print out
energy estimates along the way.
\begin{python}
def FindGroundstate(**args):
	args['imtime'] = True
	prop = SetupProblem(**args)
	
	for t in prop.Advance(10):
		E = prop.GetEnergy()
		print "t = %f, E = %f" % (t, E)

	E = prop.GetEnergy()
	print "Ground State Energy = %f" % E

	return prop
\end{python}

You can now find the ground state and energy of hydrogen by starting python and typing
\begin{python}
	execfile("example.py")
	prop = FindGroundstate()
\end{python}
This should print out a ground state energy of $\approx -0.498258$, and return the problem object as the variable prop. You can use this variable to interact with the problem. 

Whenever you make changes to example.py, you can run \inlinepy{execfile("example.py")} to reload the changes.

You can get a copy of the raw wavefunction data by typing
\begin{python}
	data = prop.psi.GetData().copy()
\end{python}
And get the radial grid and l-indices by typing
\begin{python}
	r = prop.psi.GetRepresentation().GetLocalGrid(0)
	l = prop.psi.GetRepresentation().GetLocalGrid(1)
\end{python}
The probability density can then be plotted in the r, l basis:
\begin{python}
	pcolor(l, r, abs(data)**2, shading='flat')
\end{python}

The wavefunction can also be saved to a HDF5 file, using 
\begin{python}
	prop.SaveWavefunctionHDF(filename, dataset) 
\end{python}
Usually, however, you will probably want to delete the file if it exists before saving it. To simplify that process, make the following function
\begin{python}
def SaveWavefunction(filename, dataset, psi):
	if pyprop.ProcId == 0:
		if os.path.exists(filename):
			os.unlink(filename)
	pyprop.serialization.SaveWavefunctionHDF(filename, dataset, psi)
\end{python}
Then the ground state can be saved with
\begin{python}
 	SaveWavefunction("groundstate.h5", "/wavefunction", prop.psi)
\end{python}

\subsection{Creating the Dynamic Potential}
In order to ionize anything, we will need a potential for the electric field. In this case, we will use linearly polarized light in the $z$ direction, and a $\sin^2$ shaped pulse. Add the following class to the \inlinebash{potential.cpp} file.
\begin{c++}
template<int Rank>
class LaserPotential : public PotentialBase<Rank>
{
public:
	//Required by DynamicPotentialEvaluator
	cplx TimeStep;
	double CurTime;

	//Potential parameters
	double PulseDuration;
	double Frequency;
	double Amplitude;

	//Calculated parameters
	double convolutionFrequency;
	double currentAmplitude;

	/*
	 * Called once with the corresponding config section
	 * from the configuration file. Do all one time set up routines
	 * here.
	 */
	void ApplyConfigSection(const ConfigSection &config)
	{
		config.Get("pulse_duration", PulseDuration);
		config.Get("frequency", Frequency);
		config.Get("amplitude", Amplitude);

		convolutionFrequency = M_PI / PulseDuration;
	}

	/*
	 * Called once every timestep
	 */
	void CurTimeUpdated()
	{
		if (CurTime > PulseDuration)
		{
			currentAmplitude = 0;
		}
		else
		{
			currentAmplitude = Amplitude;
			currentAmplitude *= sqr(sin(CurTime * convolutionFrequency));
			currentAmplitude *= cos(CurTime * Frequency);
		}
	}

	/*
	 * Called for every grid point at every time step. 
	 */
	inline double GetPotentialValue(const blitz::TinyVector<double, Rank> &pos)
	{
		double r = std::abs(pos(0));
		double theta = pos(1);

		double z = r * cos(theta);
		return currentAmplitude * z;
	}
};
\end{c++}
Similarly to the Coulomb potential, we must add a wrapper to it before we can use it in python. Open wrapper.pyste, and add the following line
\begin{python}
PotentialEvaluator("LaserPotential<2> 2","LaserPotential_2")
\end{python}
and recompile the project.

\subsection{Create a Propagation Problem}
We now need a config file for the propagation problem, where we will not use imaginary time, and use the additional \inlinec{LaserPotential} as well as an absorbing boundary. We will create a \inlinebash{propagation.ini} for this purpose. This new configuration file will be very similar to \inlinebash{config.ini}, and instead of copying and modifying that file, we will rather use the import-features of the configuration files to base \inlinebash{propagation.ini} on \inlinebash{config.ini}. This enables
us to use \inlinebash{config.ini} as a base, and only override certain config  variables. Create \inlinebash{propagation.ini} with the following content
\begin{python}
[Import]
files = ["config.ini"]

[InitialCondition]
type = InitialConditionType.File
format = WavefunctionFileFormat.HDF
filename = "groundstate.h5"
dataset = "/wavefunction"

[DynamicPotential]
type = PotentialType.Dynamic
classname = "LaserPotential"
pulse_duration = 10
frequency = 1.0
amplitude = 0.5

[AbsorbingPotential]
type = PotentialType.Static
classname = "core.SphericalAbsorbingPotential"

[Propagation]
potential_evaluation = ["Potential","DynamicPotential","AbsorbingPotential"]
timestep = 0.01
duration = 20
renormalization = False
\end{python}
In order to use this new config to propagate and calculate the ionization probability, we will create a function similar to the one finding the ground state
\begin{python}
def FindIonizationProbability(**args):
	args['imtime'] = False
	args['config'] = "propagation.ini"
	prop = SetupProblem(**args)

	initialPsi = prop.psi.Copy()

	for t in prop.Advance(10):
		norm = prop.psi.GetNorm()
		corr = abs(prop.psi.InnerProduct(initialPsi))**2
		print "t = %f, Norm = %f, Corr = %f" % (t, norm, corr)

	norm = prop.psi.GetNorm()
	corr = abs(prop.psi.InnerProduct(initialPsi))**2
	print "Ionization Probability = %f" % norm
	print "Initial state correlation = %f" % corr

	return prop	
\end{python}
You can now find the ionization probability by typing
\begin{python}
	FindIonizationProbability()
\end{python}
Now, we want to find the ionization probability for different field strengths. Certainly, we can change the value in the config file and rerun \inlinepy{FindIonizationProbability}. We can even use a new config file, import \inlinebash{propagation.ini}, and only override the amplitude variable. A more elegant method, however, is to do it programatically. We can add a few lines to \inlinepy{SetupConfig}, and control the amplitude with function parameters. Add the following lines to \inlinepy{SetupConfig} before \inlinepy{return conf}
\begin{python}
	if "amplitude" in args:
		amplitude = args["amplitude"]
		conf.DynamicPotential.amplitude = amplitude	
\end{python}
To find the ionization probability for a given electric field strength, you can now type
\begin{python}
 	FindIonizationProbability(amplitude=0.2)
\end{python}
For completeness, we will now make a function that calculates the ionization probability for field strengths between $0$ and $2$, and plots the results.
\begin{python}
def FindIonizationProbabilityAmplitude():
	amplitudeList = r_[0:2:0.2]
	ionizationList = zeros(len(amplitudeList), dtype=double)

	for i in range(len(amplitudeList)):
		prop = FindIonizationProbability(amplitude=amplitudeList[i])
		ionizationList[i] = prop.psi.GetNorm()

	plot(amplitudeList, ionizationList, label="Ionization Probability")
	xlabel("Electric Field Strength")
	ylabel("Ionization Probability")
	legend()

	return amplitudeList, ionizationList
\end{python}
