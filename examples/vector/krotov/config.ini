[Representation]
type = core.VectorRepresentation
rank = 1
vector_size = 50

[InitialCondition]
type = InitialConditionType.Function
function = lambda conf, x: (x[0] == 0) * 1.0

[FinalState]
states = [2]
population = [1]

[Krotov]
control_cutoff = inf
energy_penalty = 20.0
max_iterations = 10
yield_requirement = 0.999
#time_grid_size = 1000
debug = False

[ControlFunction]
type = PotentialType.Matrix
matrix_type = MatrixType.Dense
#matrix_function = GetMatrixQdot4
filename = 'input/matrix_elements-X.h5'
dataset = '/doubledot/matrixelements'
time_function = lambda conf, t: conf.e0 * conf.scaling
scaling = 3.44336611701300
e0 = 0.01

[Potential1D]
type = PotentialType.Static
#storage_model = StaticStorageModel.StorageExpValue
storage_model = StaticStorageModel.StorageValue
function = GetDiagonalElements
scaling = 0.5
size = 50

[Propagation]
#propagator = CombinedPropagator
#propagator0 = None
base_propagator = VectorPropagator
propagator = RungeKuttaPropagator
integrator_type = IntegratorType.IntegratorRKF45
#base_propagator = VectorPropagator
#propagator = OdePropagator
#propagator = PamPropagator
#propagator = ExpokitPropagator
#krylov_basis_size = 5
potential_evaluation = ["Potential1D", "ControlFunction", "Potential1D"]
#potential_evaluation = ["ControlFunction", "Potential1D"]
#potential_evaluation = ["Potential1D", "ControlFunction"]
timestep = 0.005
duration = 100.0
renormalization = False
silent = True
absolute_error = 1e-10
relative_error = 1e-10

[Distribution]
proc_array_rank = 1
initial_distribution = array([0])
